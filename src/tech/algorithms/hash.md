---
title: 散列表
date: 2025-05-25
index: false
icon: laptop-code
category:
  - 数据结构
tags:
  - hash
---

## 介绍一下散列表


## 为什么使用散列表
理想情况下实现 O(1) 时间复杂度的查找、插入、删除操作


## 拉链寻址和开放寻址的区别
- 存储结构	数组+链表/树	单一数组
- 冲突解决方式	同桶内链式存储	探测下一个空槽（线性/平方探测等）
- 空间效率	需要额外指针空间	无额外指针，内存紧凑
- 性能稳定性	高冲突时性能下降平缓	高负载因子时性能急剧下降
- 删除操作	直接链表删除	需标记为"墓碑"
- 典型实现	Java HashMap	ThreadLocalMap


## 还有其他什么方式可以解决散列哈希索引冲突
- 再哈希法（Rehashing） 
  - 使用第二哈希函数计算探测步长 
  - 公式：index = (hash1(key) + i*hash2(key)) % size
- 布谷鸟哈希（Cuckoo Hashing） 
  - 使用两个哈希表和两个哈希函数 
  - 冲突时踢出旧元素重新安置



## 对应的 Java源码中，对于哈希索引冲突提供了什么样的解决方案
- JDK1.7：数组+单向链表

- JDK1.8+：数组+单向链表/红黑树（链表长度≥8时转换）

