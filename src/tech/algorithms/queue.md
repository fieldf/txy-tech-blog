---
title: 队列
date: 2025-05-18
index: false
icon: laptop-code
category:
  - 数据结构
tags:
  - 数组
---

- 实现队列的方式？ 
  - 数组和链表都可以实现队列，java中链表实现的队列：LinkedList；数组实现的队列：ArrayDeque

- 阻塞队列和延迟队列都是干什么的？ 
  - → 阻塞队列控流量，仓库满空要等待；【await() 让线程等，signal() 叫醒线程】 
  - → 延迟队列管时间，任务到点才出来！

- 什么是阻塞？ 
  - 阻塞的是线程被阻塞住，挂起状态等待返回，非阻塞是立即返回，一般需要轮询浪费cpu

- 单端队列和双端队列，分别对应的实现类是哪个？
  - 单端队列：LinkedList、ArrayDeque、PriorityQueue
  - 双端队列：ArrayDeque、LinkedList

- 简述延迟队列/优先队列的实现方式
  - 延迟队列 
    - 核心结构：优先级堆（PriorityQueue） + 可重入锁（ReentrantLock） 
    - 排序规则：按元素到期时间升序排列 
    - 阻塞机制：Condition.await() 和 signal()
  - 优先队列
    - 核心结构：二叉堆（数组实现） 
    - 排序规则：可自定义比较器（默认自然顺序） 
    - 操作复杂度： 
      - 插入：O(log n)（上浮） 
      - 取出：O(log n)（下沉）

- 二叉堆插入/弹出元素的过程
  - 插入
  1. 将新元素放入数组末尾 
  2. 与其父节点比较：
     - 若比父节点更优先（小顶堆则更小），交换位置
  3. 重复步骤2，直到满足堆条件或到达根节点
  - 弹出
  1. 取出根节点（堆顶元素）
  2. 将数组末尾元素移到根位置
  3. 将新根与其子节点比较：
      - 选择优先级更高的子节点（小顶堆选更小的）
      - 若子节点优先级更高，交换位置
  4. 重复步骤3，直到满足堆条件或到达叶子节点

- 延迟队列的使用场景
  - 定时任务调度	按指定时间触发任务	30分钟后关闭未支付订单
  - 缓存过期清理	自动清理过期缓存	Redis的Key过期机制
  - 重试机制	失败任务延迟重试	消息发送失败后延迟5秒重试
  - 流量整形	控制请求处理速率	限制每秒最多处理100个请求
  - 会话管理	用户会话超时处理	用户15分钟无操作自动退出登录

- 延迟队列为什么添加信号量 
  - 核心原因：避免无效轮询，精准唤醒
    - Condition.await()： 
      - 阻塞，释放锁并挂起线程，零CPU消耗 
      - 进入条件等待队列 
    - Condition.signal()： 
      - 当有新元素入队且该元素是当前最早到期的时触发 
      - 将等待最久的线程从条件队列移到锁的同步队列
    - 想象你叫外卖，但餐还没做好。你有两种选择： 一直打电话问：“好了没？好了没？”（这就是轮询，费嘴皮子还费手机电量）
告诉商家：“做好后打我电话，我先眯会儿。”（这就是信号量，省力又高效）
为什么加信号量？
不叫醒你：没人通知的话，你只能干等，浪费时间精力（CPU空转）。
叫醒你：餐好了立刻通知你，立马开吃不耽误（线程及时响应）。
代码里加信号量（比如 available.signal()）的作用就是：
“别瞎忙了！有活干了，快起来干活！” —— 让等待的线程及时知道条件满足，不用白等。
    - 消费者获取到锁但是发现某一种状态达不到（获取队头元素的时候还没有），进入await等待，会释放锁；当这种状态能够达到满足时（有元素进入的时候），signal唤醒消费者的线程，被唤醒的消费者线程能够继续执行


