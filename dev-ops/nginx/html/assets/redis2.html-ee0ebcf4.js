import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as d,c as u,f as r,e as s,w as i,d as n}from"./app-9393c1ef.js";const m={};function k(h,l){const e=a("groupId"),t=a("artifactId"),o=a("version"),p=a("dependency");return d(),u("div",null,[l[6]||(l[6]=r(`<h1 id="入门" tabindex="-1"><a class="header-anchor" href="#入门" aria-hidden="true">#</a> 入门</h1><p>nosql</p><ol><li>not only sql</li><li>问题： <ol><li>关系型数据库难以对付高并发</li></ol></li><li>特点： <ol><li>方便扩展</li><li>大数据量、高性能</li><li>数据类型多样</li></ol></li><li>关系型 <ol><li>结构化</li><li>SQL</li><li>数据和关系单独的表中</li><li>一致性</li><li>事务</li></ol></li><li>nosql <ol><li>没有固定查询语句</li><li>键值对、列存储、文档存储、图形数据库</li><li>最终一致性</li><li>CAP定理和BASE（异地多活）</li><li>高性能、高可用、高扩展</li></ol></li><li>分类 <ol><li>KV键值对：redis</li><li>文档型数据库 <ol><li>mongodb（bson和json一样） <ol><li>基于分布式文件存储</li></ol></li></ol></li><li>列存储数据库 <ol><li>HBase</li><li>分布式文件系统</li></ol></li><li>图关系数据库 <ol><li>放的是关系，比如朋友圈社交网络、广告推荐 <ol><li>neo4j、infogrid</li></ol></li></ol></li></ol></li></ol><p>redis</p><ol><li>remote dictionary server</li><li>内存+可持久日志（RDB+AOF）</li><li>key-value</li><li>效率高</li><li>发布订阅，队列</li><li>地图信息分析</li><li>多数据类型</li><li>集群</li><li>事务</li></ol><h2 id="下载" tabindex="-1"><a class="header-anchor" href="#下载" aria-hidden="true">#</a> 下载</h2><ol><li>wget http://download.redis.io/releases/redis-6.0.6.tar.gz</li><li>解压：tar -xzf redis-6.0.6.tar.gz</li><li>cd redis-6.0.6</li><li>make</li><li>拷贝配置文件 <ol><li>cp ~/redis-6.0.6/redis.conf /usr/local/redis/bin/redis-conf/redis.conf</li></ol></li><li>启动： <ol><li>src/redis-server redis-config/redis.conf</li></ol></li><li>查看 <ol><li>ps -ef |grep redis</li></ol></li><li>客户端 <ol><li>redis-cli -h 127.0.0.1 -p 6379</li></ol></li></ol><h2 id="性能测试" tabindex="-1"><a class="header-anchor" href="#性能测试" aria-hidden="true">#</a> 性能测试</h2><ol><li>redis-benchmark官网自带的压力测试工具</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672193139005-00d40479-99d8-42e3-af58-5cb974417772.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>使用方式 <ol><li>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000</li></ol></li></ol><h2 id="单线程为什么快" tabindex="-1"><a class="header-anchor" href="#单线程为什么快" aria-hidden="true">#</a> 单线程为什么快</h2><ol><li>内存操作 <ol><li>性能瓶颈在内存+带宽。</li><li>不在cpu，因此用单线程。</li></ol></li><li>多线程需要进行cpu上下文切换。</li><li>采用网络IO多路复用。 <ol><li>多连接保证高吞吐量</li></ol></li><li>使用跳表、链表、动态字符串、压缩列表实现数据结构。效率高。</li></ol><h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h1><h2 id="五大数据类型" tabindex="-1"><a class="header-anchor" href="#五大数据类型" aria-hidden="true">#</a> 五大数据类型</h2><ol><li>文档 <ol><li>http://www.redis.cn/commands.html</li></ol></li><li>数据类型指的是value</li></ol><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> string</h3><p>命令</p><ol><li>keys *</li><li>exists name <ol><li><blockquote><p>=1存在，&lt;=0不存在</p></blockquote></li></ol></li><li>move name 1：迁移到数据库1</li><li>select 1：使用数据库1</li><li>set name yyyy <ol><li>expire name 10 <ol><li>ttl name</li></ol></li><li>get name</li><li>append name &quot;hello&quot; #追加</li><li>strlen name</li></ol></li><li>set views 1 <ol><li>incr views # 自增1</li><li>decr views # 自减1</li><li>incrby views 2 # 自增2</li><li>decrby views 2 # 自减2</li></ol></li><li>set key1 &quot;hello world&quot; <ol><li>getrange key1 0 4</li><li>getrange key1 0 -1：-1代表尾部</li><li>setrange key1 1 xx：从e替换成xx得到hxxlo world</li></ol></li><li>setex <ol><li>设置过期时间</li><li>setex key4 10 value4 # 10秒钟</li></ol></li><li>setnx <ol><li>不存在再设置</li><li>setnx key1 value1：如果key1存在设置不成功。</li><li>setnx key2 value1：key2不存在，设置成功，返回1.</li></ol></li><li>mset和mget <ol><li>mset k1 v1 k2 v2 k3 v3</li><li>mget k1 k2 k3</li><li>msetnx k1 v1 k4 v4 <ol><li>原子性，要么全部成功，要么全部失败。</li></ol></li></ol></li><li>getset：先get后set <ol><li>getset db redis # 如果不存在，返回nil，并设置值。</li><li>getset db mongodb # 如果存在，返回redis，并设置mongodb</li></ol></li><li>type name：类型</li><li>举例： 1.<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>set user:1 {name:zhangsan, age:3}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><pre><code>1. 保存一个对象。
</code></pre></li></ol><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> list</h3><p>用途</p><ol><li>用做栈、队列、阻塞队列</li><li>栈 <ol><li>左进左出</li></ol></li><li>队列 <ol><li>左进右出</li></ol></li></ol><p>命令</p><ol><li>lpush list one <ol><li>lpush list two</li><li>lrange list 0 -1：two one</li><li>rpush list zero</li></ol></li><li>lpop list <ol><li>rpop list</li></ol></li><li>lindex list 0</li><li>llen list</li><li>lrem list 2 value4 <ol><li>从左起删除两个value4</li></ol></li><li>ltrim list 1 2 <ol><li>只保留1到2的数据。</li></ol></li><li>rpoplpush mylist myotherlist <ol><li>lrange mylist 0 -1 <ol><li>hello1 hello2 hello3</li></ol></li><li>移除列表最后一个元素，移动到新的列表中</li><li>lrange mylist 0 -1 <ol><li>hello1 hello2</li></ol></li><li>lrange myother list 0 -1 <ol><li>hello3</li></ol></li></ol></li><li>lset <ol><li>列表中指定下标的值替换为另一个值，更新操作</li><li>lset list 0 item：如果列表不存在，则报错。</li></ol></li><li>linsert <ol><li>linsert list before|after value3 value4</li><li>在value3的前面或后面插入value4。</li></ol></li></ol><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> set</h3><p>结构</p><ol><li>hash结构</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672216075092-ac79e261-2e0d-4f62-a955-1d3256385256.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>命令</p><ol><li>sadd set hello world</li><li>smembers set <ol><li>返回set集合中的元素</li></ol></li><li>sismember set hello <ol><li>hello在不在集合中，返回1</li></ol></li><li>scard set <ol><li>获取集合元素个数</li></ol></li><li>srem set world <ol><li>移除world元素</li></ol></li><li>srandmember set <ol><li>随机抽取一个元素</li><li>srandmember set 2 <ol><li>随机抽取2个元素。</li></ol></li></ol></li><li>spop set <ol><li>随机删除一个元素。</li></ol></li><li>smove set setother &quot;kkk&quot; <ol><li>将kkk移动到setother集合中。</li></ol></li><li>sdiff key1 key2 <ol><li>key1和key2的差集，key1-key2</li></ol></li><li>sinter key1 key2 <ol><li>交集</li></ol></li><li>sunion key1 key2 <ol><li>并集</li></ol></li></ol><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> hash</h3><ol><li>key field value</li></ol><p>命令</p><ol><li>hset myhash field xxx</li><li>hget myhash field</li><li>hmset myhash k1 v1 k2 v2</li><li>hmset myhash k1 k2</li><li>hgetall myhash（慎用） <ol><li>获取所有key和value</li></ol></li><li>hlen myhash <ol><li>获取长度</li></ol></li><li>hexists myhash field1 <ol><li>是否存在key，存在1</li></ol></li><li>hkeys myhash <ol><li>获取所有key</li></ol></li><li>hvals myhash <ol><li>获取所有value</li></ol></li><li>hincrby hash1 field1 1 <ol><li>hget hash1 field1：1</li></ol></li><li>hsetnx hash2 field1 value1 <ol><li>不存在设置成功</li></ol></li></ol><h3 id="zset" tabindex="-1"><a class="header-anchor" href="#zset" aria-hidden="true">#</a> zset</h3><p>语法</p><ol><li>zadd key score value</li><li>zadd myset 1 one</li><li>zadd myset 2 two 3 three</li><li>zrange myset 0 -1 <ol><li>one two three</li><li>zrange myset 0 -1 WITHSCORES</li><li>反向排列 <ol><li>zrevrange myset 0 -1 WITHSCORES</li></ol></li></ol></li><li>zrangebyscore zset 15 22 <ol><li>根据score范围拿出值。</li></ol></li><li>zrem myset one：移除one</li><li>zcard myset：集合元素个数</li><li>zcound myset 15 22：查询元素score在15到22区间的count</li></ol><h2 id="三种特征数据类型" tabindex="-1"><a class="header-anchor" href="#三种特征数据类型" aria-hidden="true">#</a> 三种特征数据类型</h2><h3 id="geospatial" tabindex="-1"><a class="header-anchor" href="#geospatial" aria-hidden="true">#</a> geospatial</h3><ol><li>geoadd china:city 116.40 39.90 beijing</li><li>geoadd china:city 121.47 31.23 shanghai</li><li>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen</li><li>geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</li><li>获取当前坐标 <ol><li>geopos china:city beijing</li></ol></li><li>获取两个位置距离 <ol><li>geodist china:city beijing shanghai km</li><li>m km mi英里 ft英尺</li></ol></li><li>以给定的经纬度为中心，找出某一半径内的元素 <ol><li>georadius china:city 110 30 1000km</li><li>withcoord 显示定位信息</li><li>withdist 显示到中心点距离</li><li>count 1 指定数量</li></ol></li><li>找指定元素周围的其他元素 <ol><li>georadiusbymember china:city shanghai 1000 km <ol><li>hangzhou</li><li>shanghai</li></ol></li></ol></li><li>zrange china:city 0 -1</li></ol><h3 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> hyperloglog</h3><p>UV：根据ip判断。一天内同一个访客仅被计算一次。</p><p>优点：</p><ol><li>占用内存小12KB</li><li>有0.81%错误率。</li></ol><p>命令：</p><ol><li>pfadd mykey a b c d e f g h i j</li><li>pfcount mykey</li><li>pfmerge mykey3 mykey mykey2 <ol><li>合并mykey和mykey2=&gt;mykey3</li></ol></li></ol><h3 id="bitmap位图" tabindex="-1"><a class="header-anchor" href="#bitmap位图" aria-hidden="true">#</a> bitmap位图</h3><ol><li>表示某个元素对应的值，或0或1.</li><li>打卡 <ol><li>setbit sign 0 1 # 周一打卡了</li><li>setbit sign 1 0 # 周二没打卡</li><li>setbit sign 2 0 # 周三未打卡</li><li>getbit sign 2：周三打卡了吗？</li><li>bitcount sign：统计打卡的数量。</li></ol></li></ol><h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><p>redis事务本质</p><ol><li>一组命令的集合。</li><li>按顺序执行。</li><li>一次性、顺序性、排他性的执行一组命令。</li><li>单条命令保证原子性，事务不保证原子性。</li><li>如果命令有错，事务中所有命令都不会被执行。</li><li>如果命令执行结果报错，其他命令可以正常执行，错误命令抛出异常。</li></ol><p>事务命令</p><ol><li>开启事务：multi</li><li>命令入队</li><li>执行事务：exec</li><li>撤销事务：discard</li></ol><p>代码：</p><ol><li>multi</li><li>set k1 v1</li><li>set k2 v2</li><li>get k2</li><li>set k3 v3</li><li>exec</li></ol><h2 id="监视watch" tabindex="-1"><a class="header-anchor" href="#监视watch" aria-hidden="true">#</a> 监视watch</h2><ol><li>悲观锁 <ol><li>悲观，无论什么时候都会加锁。</li><li>影响效率，实际情况一般使用乐观锁。</li></ol></li><li>乐观锁 <ol><li>乐观，认为什么时候都不会出现问题。</li><li>不上锁。更新数据的时候会判断一下，在此期间是否修改过监视的数据。</li></ol></li></ol><p>watch作用</p><ol><li>监控1或多个key。</li><li>一旦其中一个key被修改(或删除)，之后的事务就不执行。</li><li>监控持续到exec命令。</li></ol><p>转账举例</p><ol><li>set money 300</li><li>set out 200</li><li>watch money</li><li>multi</li><li>decrby money 20</li><li>incrby out 20</li><li>另一个线程设置set money 200</li><li>exec，事务没有执行成功。</li></ol><p>如果修改失败，重新监控获取最新值</p><ol><li>UNWATCH先解锁</li><li>WATCH money # 获取最新的值，相当于mysql的select version</li><li>multi</li><li>DECRBY money</li><li>INCRBY out</li><li>exec # 执行时会对比监视的值，如果发生变化会执行失败。</li></ol><h2 id="jedis" tabindex="-1"><a class="header-anchor" href="#jedis" aria-hidden="true">#</a> jedis</h2><p>介绍：</p><ol><li>java操作redis的工具。</li><li>redis官方推荐。</li></ol><p>步骤</p><ol><li>依赖</li></ol>`,68)),s(p,null,{default:i(()=>[s(e,null,{default:i(()=>l[0]||(l[0]=[n("redis.clients")])),_:1}),s(t,null,{default:i(()=>l[1]||(l[1]=[n("jedis")])),_:1}),s(o,null,{default:i(()=>l[2]||(l[2]=[n("3.2.0")])),_:1})]),_:1}),s(p,null,{default:i(()=>[s(e,null,{default:i(()=>l[3]||(l[3]=[n("com.alibaba")])),_:1}),s(t,null,{default:i(()=>l[4]||(l[4]=[n("fastjson")])),_:1}),s(o,null,{default:i(()=>l[5]||(l[5]=[n("1.2.68")])),_:1})]),_:1}),l[7]||(l[7]=r(`<ol start="2"><li>创建Jedis <ol><li>Jedis jedis=new Jedis(&quot;localhost&quot;, 6379)</li><li>System.out.println(jedis.ping()); // PONG</li></ol></li><li>jedis实现事务</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Jedis</span> jedis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//        System.out.println(jedis.ping());</span>
    jedis<span class="token punctuation">.</span><span class="token function">flushDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">JSONObject</span> jsonObject<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;xxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 开启事务</span>
    <span class="token class-name">Transaction</span> multi<span class="token operator">=</span>jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> result<span class="token operator">=</span>jsonObject<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        multi<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;user1&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        multi<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;user2&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>
        multi<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行事务</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        multi<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//放弃事务</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;user1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;user2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>1. 出现了异常，进入catch，放弃事务，两个命令都没有执行。
</code></pre><h2 id="springboot整合redis" tabindex="-1"><a class="header-anchor" href="#springboot整合redis" aria-hidden="true">#</a> springboot整合redis</h2><p>依赖</p><ol><li></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>  
   <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>  
   <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>  
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>springboot2.x之后，原来的jedis被替换为lettuce。 <ol><li>lettuce：采用netty。更像NIO。</li><li>jedis：采用的直连，更像BIO。</li></ol></li><li>springboot所有的配置类，都有一个自动配置类。 <ol><li>RedisTemplate</li></ol></li><li>自动配置类都绑定一个properties配置文件。 <ol><li>RedisProperties</li></ol></li><li>配置连接 <ol><li>spring.redis.host=127.0.0.1</li><li>spring.redis.port=6379</li></ol></li><li>代码 <ol><li>@Autowired<br> private RedisTemplate redisTemplate;<br> @Autowired<br> private StringRedisTemplate stringRedisTemplate;<br> public void test() {<br> redisTemplate.opsForValue().set(&quot;mszlu&quot;,&quot;hello&quot;);<br> stringRedisTemplate.opsForValue().set(&quot;stringmszlu&quot;, &quot;hello string&quot;);<br> System.out.println(redisTemplate.opsForValue().get(&quot;mszlu&quot;)); System.out.println(stringRedisTemplate.opsForValue().get(&quot;stringmszlu&quot;));<br> }</li></ol></li><li>自定义序列化配置</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
* 编写的自己的 RedisTemplate
*/</span>
<span class="token annotation punctuation">@Configuration</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Bean</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;all&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 为了开发方便，一般使用 &lt;String, Object&gt;</span>
            <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 序列化配置</span>
            <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span><span class="token constant">ALL</span><span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span><span class="token constant">ANY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span><span class="token constant">NON_FINAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// String 的序列化</span>
            <span class="token class-name">StringRedisSerializer</span> stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// key 采用 String 的序列化方式</span>
            template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// hash 的 key 也采用 String 的序列化方式</span>
            template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// value 序列化方式采用 Jackson</span>
            template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// hash 的 value 序列化方式采用 Jackson</span>
            template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> template<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="redis配置文件和持久化" tabindex="-1"><a class="header-anchor" href="#redis配置文件和持久化" aria-hidden="true">#</a> redis配置文件和持久化</h1><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h2><p>停止进程：</p><ol><li>kill -9 号</li></ol><p>network网络</p><ol><li>bind 127.0.0.1 # 绑定的ip只有127.0.0.1可以访问redis服务，0.0.0.0代表所有ip都可以访问。</li><li>protected-mode no # 保护模式</li><li>port 6379 # 端口设置</li></ol><p>general</p><ol><li>deamonize yes # 守护进程方式启动。</li><li>pidfile /var/run/redis_6379.pid # 如果后台启动，我们需要指定一个pid文件。</li><li>loglevel debug|verbose|notice|warning</li><li>logfile &quot;&quot; # 日志文件的位置</li><li>databases 16 # 数据库的数量，默认16</li><li>always-show-logo yes # 是否总是显示LOGO</li></ol><p>持久化/快照配置rdb</p><ol><li>save 900 1 <ol><li>如果900s内，至少有1个key进行了修改，进行持久化操作。</li></ol></li><li>save 300 10 <ol><li>如果300s内，至少有10个key进行了修改，进行持久化操作。</li></ol></li><li>stop-writes-on-bgsave-error yes # 如果持久化出错，是否还要继续工作。</li><li>rdbcompression yes # 是否压缩rdb文件，需要消耗一些cpu资源。</li><li>rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验。</li><li>dir ./ # rdb文件保存的目录。</li></ol><p>security</p><ol><li>requirepass 123456 <ol><li>设置密码，客户端连接时使用auth 123456</li></ol></li></ol><p>client</p><ol><li>maxclients 10000 #设置能连接上redis的最大客户端数量</li><li>maxmemory &lt;bytes&gt; # redis设置最大的内存数量。</li><li>maxmemory-policy noeviction # 内存达到上限之后的处理策略 <ol><li>noeviction：当内存达到阈值的时候，所有引起申请内存的命令会报错。</li><li>allkeys-lru：在所有键中采用lru算法删除键，直到腾出足够内存为止。</li><li><strong>volatile-lru</strong>：在设置了过期时间的键中采用lru算法删除键，直到腾出足够内存为止。</li><li>allkeys-random：在所有键中采用随机删除键，直到腾出足够内存为止。</li><li>volatile-random：在设置了过期时间的键中随机删除键，直到腾出足够内存为止。</li><li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</li></ol></li></ol><p>AOF模式</p><ol><li>appendonly no # 默认不开启AOF模式，默认使用RDB方式持久化，大部分情况下RDB完全够用。</li><li>appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字。</li><li>appendfsync always # 每次修改都会sync消耗性能。</li><li>appendfsync everysec # 每秒执行一次</li><li>appendfsync no # 不执行sync，操作系统自己同步数据，速度最快。</li></ol><h2 id="持久化-1" tabindex="-1"><a class="header-anchor" href="#持久化-1" aria-hidden="true">#</a> 持久化</h2><h3 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h3><ol><li>redis database</li><li>过程</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672318068576-935fcd03-d133-43ec-a1b9-aff2a28b1908.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>手动触发 <ol><li>save：阻塞</li><li>bgsave：非阻塞（一般用这个）</li></ol></li><li>客户端清除数据 <ol><li>删除dump.rdb</li><li>客户端清除所有数据flushall</li><li>重新启动后数据才会恢复。</li><li>再次检验dump.rdb又出现了。</li></ol></li><li>优点 <ol><li>适合大规模数据恢复。</li><li>对数据完整性要求不高。</li></ol></li><li>缺点 <ol><li>需要一定的时间间隔进行操作，如果redis宕机，最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的空间。</li></ol></li></ol><h3 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h3><ol><li>append only file</li><li>记录set key value这样的命令。</li><li>redis启动之初会读取文件(执行命令)重新构建数据。</li><li>类似binlog</li><li>保存为xxx.aof，如appendonly.aof文件。</li><li>修复aof文件 <ol><li>redis-check-aof --fix appendonly.aof</li><li>重启服务。</li></ol></li><li>优点 <ol><li>每次修改都同步，文件完整性好。</li><li>每秒同步一次，可能会丢失一秒的数据。</li><li>从不同步，效率最高的。</li></ol></li><li>缺点 <ol><li>AOF远远大于RDB，修复的速度比RDB慢。</li><li>AOF运行效率比RDB慢，所以redis默认是rdb配置。</li></ol></li><li>问题 <ol><li>aof有重写功能，只会保留最后一条修改的命令。</li></ol></li></ol><p>性能建议</p><ol><li>rdb做后备用途，建议只在slave上持久化rdb，而且15分钟备份一次就够了。 <ol><li>save 900 1</li></ol></li><li>AOF代价带来持续的IO。磁盘会导致cpu占用到这了，没法做别的。</li><li>同时开启两种持久化方式。</li></ol><h1 id="发布订阅" tabindex="-1"><a class="header-anchor" href="#发布订阅" aria-hidden="true">#</a> 发布订阅</h1><ol><li>pub/sub：发送者发送消息，订阅者接收消息。</li><li>redis客户端可以订阅任意数量的频道。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672323013826-47623a52-4233-454d-a782-e4e1e5f08445.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>场景 <ol><li>实时消息系统</li><li>实时聊天</li><li>订阅、关注系统</li><li>稍微复杂的场景更多的使用消息中间件MQ。</li></ol></li><li>命令</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672323289320-71ab939b-b6a9-4ec2-9668-2f0f5da7af13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="5"><li>举例 <ol><li>订阅者1 <ol><li>subscribe redisChat</li></ol></li><li>订阅者2 <ol><li>subscribe redisChat</li></ol></li><li>发布者 <ol><li>publish redisChat &quot;hello redis pub sub&quot;</li></ol></li></ol></li></ol><h1 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制" aria-hidden="true">#</a> 主从复制</h1><p>概念</p><ol><li>主节点master/leader的数据复制到从节点slave/follower。</li><li>数据复制是单向的，只能从主节点到从节点。</li><li>master以写为主，slave以读为主。</li></ol><p>作用</p><ol><li>数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：主节点出现问题，由从节点提供服务，实现故障恢复。</li><li>负载均衡：主从复制的基础上配合读写分离（主节点提供写服务，从节点提供读服务），写数据的时候连主节点，读的时候连从节点。</li><li>高可用基石：主从复制、哨兵模式、集群。</li></ol><p>配置rz-&gt;lrzsz</p><ol><li>主机6381，从机6382和6383</li><li>直接使用命令配置，但是重启失效。 <ol><li>配置从</li><li>SLAVEOF 127.0.0.1 6381</li><li>info replication</li></ol></li><li>使用配置文件。 <ol><li>配置从</li><li>replicaof ip port</li></ol></li><li>port 6381</li></ol><h1 id="daemonize-no" tabindex="-1"><a class="header-anchor" href="#daemonize-no" aria-hidden="true">#</a> daemonize no</h1><h1 id="logfile-6381-log" tabindex="-1"><a class="header-anchor" href="#logfile-6381-log" aria-hidden="true">#</a> logfile &quot;6381.log&quot;</h1><p>dir /redis/data<br> dbfilename &quot;dump-6381.rdb&quot;<br> appendfilename &quot;appendonly-6381.aof&quot; 5. port 6382</p><h1 id="daemonize-no-1" tabindex="-1"><a class="header-anchor" href="#daemonize-no-1" aria-hidden="true">#</a> daemonize no</h1><h1 id="logfile-6382-log" tabindex="-1"><a class="header-anchor" href="#logfile-6382-log" aria-hidden="true">#</a> logfile &quot;6382.log&quot;</h1><p>dir /redis/data<br> dbfilename &quot;dump-6382.rdb&quot;<br> appendfilename &quot;appendonly-6382.aof&quot;<br> slaveof 127.0.0.1 6381 6. port 6383</p><h1 id="daemonize-no-2" tabindex="-1"><a class="header-anchor" href="#daemonize-no-2" aria-hidden="true">#</a> daemonize no</h1><h1 id="logfile-6383-log" tabindex="-1"><a class="header-anchor" href="#logfile-6383-log" aria-hidden="true">#</a> logfile &quot;6383.log&quot;</h1><p>dir /redis/data<br> dbfilename &quot;dump-6383.rdb&quot;<br> appendfilename &quot;appendonly-6383.aof&quot;<br> slaveof 127.0.0.1 6381 7. 启动3台 1. redis-server redis-6381.conf 2. redis-server redis-6382.conf 3. redis-server redis-6383.conf 8. 测试 1. redis-cli -p 6381 1. set mszlu haha 2. redis-cli -p 6382 1. get mszlu -&gt; haha 3. 说明数据同步实现了。 9. 从机只能读，不能写。 10. 复制原理 1. slave启动成功连接到master后会发送一个sync同步命令。 2. master接收到命令后执行bgsave，将rdb数据文件传送到slave。 3. 全量复制：slave接收到数据库文件后，将其存盘并加载到内存。 4. 增量复制：master继续将新的修改命令传给slave，完成同步。 5. 一旦重新连接master，一次全量复制将被自动执行。</p><h1 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h1><p>背景</p><ol><li>主服务器宕机后，需要手动将一台服务器切换为主服务器。 <ol><li>费时费力</li><li>造成一段时间服务不可用。</li></ol></li></ol><p>概述</p><ol><li>redis2.8开始。</li><li>哨兵是一个独立的进程。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672471867276-904441de-c088-4d86-a7f9-39c50c6a0d81.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1672471963259-b3f41836-bc40-4374-814b-2fe1c0a305cb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>哨兵：</p><ol><li>后台哨兵监控主服务器是否故障。ping/pong</li><li>哨兵1认为主服务器挂掉：主观下线</li><li>达到一定个数的哨兵都认为下线：客观下线。</li><li>如果故障了根据投票数选哨兵节点。</li><li>选出的哨兵节点leader进行故障转义/主从切换。</li><li>从slave中选择一个作为master <ol><li>速度快、数据新的可能会作为新的master。</li><li>数据新 <ol><li>master这里有一个增量同步的队列，有一个offset。</li><li>哪一个slave的offset大，表示数据越新。</li></ol></li></ol></li></ol><p>配置</p><ol><li>6401主，6402/6403从 <ol><li>port 6401<br> dir &quot;/redis/data&quot;<br> dbfilename &quot;dump-6401.rdb&quot;</li><li>port 6402<br> dir &quot;/redis/data&quot;<br> dbfilename &quot;dump-6402.rdb&quot;<br> slaveof 127.0.0.1 6401</li><li>port 6403<br> dir &quot;/redis/data&quot;<br> dbfilename &quot;dump-6403.rdb&quot;<br> slaveof 127.0.0.1 6401</li></ol></li><li>哨兵节点26401、26402/26403 <ol><li>port 26401<br> dir &quot;/redis/data&quot;<br> sentinel monitor mymaster 127.0.0.1 6401 2<br> sentinel down-after-milliseconds mymaster 5000<br> #sentinel failover-timeout mymaster 20000<br> #sentinel parallel-sync mymaster 1<br> #sentinel deny-scripts-reconfig yes</li><li>port 26402<br> dir &quot;/redis/data&quot;<br> sentinel monitor mymaster 127.0.0.1 6401 2 # 投票的数量，投两票就成功<br> sentinel down-after-milliseconds mymaster 5000<br> #sentinel failover-timeout mymaster 20000<br> #sentinel parallel-sync mymaster 1<br> #sentinel deny-scripts-reconfig yes</li><li>port 26403<br> dir &quot;/redis/data&quot;<br> sentinel monitor mymaster 127.0.0.1 6401 2<br> sentinel down-after-milliseconds mymaster 5000<br> #sentinel failover-timeout mymaster 20000<br> #sentinel parallel-sync mymaster 1<br> #sentinel deny-scripts-reconfig yes</li><li>config/sentinel/ <ol><li>把6个配置文件放进来</li></ol></li><li>启动redis主从 <ol><li>redis-server /redis/config/sentinel/redis-6401.conf</li><li>redis-server /redis/config/sentinel/redis-6402.conf</li><li>redis-server /redis/config/sentinel/redis-6403.conf</li></ol></li><li>sentinel <ol><li>redis-sentinel /redis/config/sentinel/redis-sentinel-26401.conf</li><li>redis-sentinel /redis/config/sentinel/redis-sentinel-26402.conf</li><li>redis-sentinel /redis/config/sentinel/redis-sentinel-26403.conf</li></ol></li></ol></li><li>redis-cli -p 6401 <ol><li>info查看主从信息。</li></ol></li></ol><h1 id="集群" tabindex="-1"><a class="header-anchor" href="#集群" aria-hidden="true">#</a> 集群</h1><p>简介：</p><ol><li>无中心结构。</li><li>多个节点之间自动进行数据分片的能力。</li><li>支持节点动态添加与移除。</li><li>部分节点不可用时进行自动故障转移。</li><li>高性能可扩展，支持扩展到1000个节点。</li></ol><h2 id="哈希槽" tabindex="-1"><a class="header-anchor" href="#哈希槽" aria-hidden="true">#</a> 哈希槽</h2><p>定义：</p><ol><li>redis-cluster有16384（2的14次方）个哈希槽，每个key通过CRC16校验后对16384取模决定放到那个槽。</li><li>集群每个主节点负责一部分hash槽。 <ol><li>3个节点。</li><li>节点A包含0-5500哈希槽。</li><li>节点B包含5501-11000哈希槽。</li><li>节点C包含11001到16383号哈希槽。</li></ol></li></ol><p>客户端向集群请求的处理过程：</p><ol><li>客户端根据请求的键计算得到哈希槽。 <ol><li>crc16(key)%16384</li></ol></li><li>假设请求的键对应的哈希值落在了节点A负责的哈希槽范围内。</li><li>客户端向任意节点发送请求，让该节点帮助它找到负责该哈希槽的节点。 <ol><li>如果这个节点就是负责该哈希槽的节点，即自身节点，也就是找到了。执行命令。</li><li>否则让这个节点负责将请求转发到负责该哈希槽的节点。</li><li>MOVED。客户端重定向。</li></ol></li><li>哈希槽的状态可能是MIGRATING。 <ol><li>迁移状态。</li><li>客户端的请求无法对这个哈希槽的键进行写操作。</li><li>但可以读。</li></ol></li></ol><h2 id="集群搭建" tabindex="-1"><a class="header-anchor" href="#集群搭建" aria-hidden="true">#</a> 集群搭建</h2><p>方式：</p><ol><li>配置服务器3主3从</li><li>建立通信</li><li>分槽</li><li>搭建主从。</li></ol><p>Cluster配置</p><ol><li>是否启用cluster，加入cluster节点 <ol><li>cluster-enabled yes|no</li></ol></li><li>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容。 <ol><li>cluster-config-file filename</li></ol></li><li>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点。 <ol><li>cluster-node-timeout milliseconds</li></ol></li><li>master连接的slave最小数量 <ol><li>cluster-migration-barrier min_slave_number</li></ol></li><li>cluster-6501.conf <ol><li>port 6501<br> dir &quot;/redis/data&quot;<br> dbfilename &quot;dump-6501.rdb&quot;<br> cluster-enabled yes<br> cluster-config-file &quot;cluster-6501.conf&quot;<br> cluster-node-timeout 5000</li></ol></li></ol><p>节点操作命令：</p><ol><li>查看集群节点信息 <ol><li>cluster nodes</li></ol></li><li>更改slave指向新的master <ol><li>cluster replicate master-id</li></ol></li><li>发现一个新节点，新增master <ol><li>cluster meet ip:port</li></ol></li><li>忽略一个没有solt的节点 <ol><li>cluster forget server_id</li></ol></li><li>手动故障转移 <ol><li>cluster failover</li></ol></li></ol><p>redis-cli命令</p><ol><li>创建集群 <ol><li>redis-cli --cluster create masterhost1:masterport1 masterhost2:masterport2 masterhost3:masterport3 [masterhostn:masterportn ...] slavehost1:slaveport1 slavehost2:slaveport2 slavehost3:slaveport3 --cluster-replicas n <ol><li>master与slave的数量要匹配，一个master对应n个slave，由最后的参数n决定。</li><li>master与slave的匹配顺序为第一个master与前n个slave分为一组，形成主从结构。</li></ol></li></ol></li><li>添加master到当前集群中，连接时可以指定任意现有节点地址和端口。 <ol><li>redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port</li></ol></li></ol><p>创建集群过程</p><ol><li>mkdir cluster/ <ol><li>cd cluster/</li></ol></li><li>上传8个配置文件cluster-6501.conf。</li><li>启动三主三从 <ol><li>redis-server cluster/cluster-6501.conf</li><li>redis-server cluster/cluster-6502.conf</li><li>redis-server cluster/cluster-6503.conf</li><li>redis-server cluster/cluster-6504.conf</li><li>redis-server cluster/cluster-6505.conf</li><li>redis-server cluster/cluster-6506.conf</li></ol></li><li>一个客户端 <ol><li>创建集群 <ol><li>redis-cli --cluster create masterhost1:masterport1 masterhost2:masterport2 masterhost3:masterport3 slavehost1:slaveport1 slavehost2:slaveport2 slavehost3:slaveport3 --cluster-replicas n</li><li>redis-cli --cluster create 127.0.0.1:6501 127.0.0.1:6502 127.0.0.1:6503 127.0.0.1:6504 127.0.0.1:6505 127.0.0.1:6506 --cluster-replicas 1</li><li>--cluster-replicas：一个master对应n个slave。</li></ol></li><li>添加master到当前集群中，连接时可以指定任意现有节点地址和端口。 <ol><li>redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port</li><li>redis-server cluster/cluster-6507.conf <ol><li>启动一个6507</li></ol></li><li>redis-cli --cluster add-node 127.0.0.1:6507 127.0.0.1:6501</li></ol></li><li>添加slave <ol><li>redis-cli --cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</li></ol></li><li>删除节点，如果节点是master，必须保障其中没有槽 <ol><li>redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id</li></ol></li><li>重新分槽，分槽是从具有槽的master中划分一部分给其他master，过程中不创建新的槽。 <ol><li>redis-cli --cluster reshard new-master-host:new-master:port --cluster-from srcmaster-id1, src-master-id2, src-master-idn --cluster-to target-master-id --cluster-slots slots</li><li>redis-cli --cluster reshard 127.0.0.1:6507 --cluster-from id1,id2,id3 --cluster-to target-master-id(cluster node查看的) --cluster-slots 1000 # 转移1000个槽</li></ol></li><li>重新分配槽，中具有槽的master中分配指定数量的槽到另一个master中，常用于清空指定master中的槽。 <ol><li>redis-cli --cluster reshard src-master-host:src-master-port --cluster-from srcmaster-id --cluster-to target-master-id --cluster-slots --cluster-yes</li></ol></li></ol></li></ol><p>测试集群</p><ol><li>客户端 <ol><li>redis-cli -p 6501 -c</li></ol></li><li>set mszlu haha <ol><li>-&gt; Redirected to slot [7859] located at 127.0.0.1:6502</li><li>重定向到另一个主节点。</li></ol></li></ol><p>测试添加新节点master</p><ol><li>客户端 <ol><li>redis-cli -p 6501 -c</li></ol></li><li>查看集群节点 <ol><li>cluster nodes</li></ol></li><li>分槽</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2023/png/22839467/1672576549582-67c81a8c-a816-4358-9dda-08584c9833d7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2023/png/22839467/1672576701844-8666de64-1747-4517-a3db-9e371b31bebe.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,92))])}const v=c(m,[["render",k],["__file","redis2.html.vue"]]);export{v as default};
