import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as u,o as a,c as p,f as d,b as i,d as o,e as r,w as s}from"./app-9393c1ef.js";const f={},b={id:"minorgc",tabindex:"-1"},e={id:"fullgc",tabindex:"-1"},g={id:"加载",tabindex:"-1"},E={id:"验证",tabindex:"-1"},C={id:"准备",tabindex:"-1"},k={id:"解析",tabindex:"-1"},y={id:"初始化",tabindex:"-1"},v={start:"2"},F={start:"3"};function m(D,l){const n=u("font");return a(),p("div",null,[l[304]||(l[304]=d('<h1 id="·jvm" tabindex="-1"><a class="header-anchor" href="#·jvm" aria-hidden="true">#</a> ·JVM</h1><h2 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制" aria-hidden="true">#</a> 运行机制</h2><p>源文件-&gt;编译器-&gt;字节码-&gt;JVM-&gt;机器码</p><ol><li>Java源文件被编译器编译成字节码文件。</li><li>JVM的即时编译器将字节码文件编译成相应操作系统的机器码。【解释器不同虚拟机相同】</li><li>机器码是靠调用相应操作系统的本地方法库执行相应的方法。</li><li>一个进程对应一个java虚拟机实例。</li></ol><h2 id="jvm包括什么" tabindex="-1"><a class="header-anchor" href="#jvm包括什么" aria-hidden="true">#</a> JVM包括什么？</h2><p>包括类加载器，运行时数据区，执行引擎和本地接口库。</p><ol><li>类加载器：用于将字节码文件加载到JVM中。</li><li>运行时数据区：用于存储JVM运行过程中产生的数据。</li><li>执行引擎： <ol><li>包括即时编译器JIT-&gt;将字节码编译成具体的机器码。</li><li>垃圾回收器：回收在运行过程中不再使用的对象。</li></ol></li><li>本地接口库JNI：调用本地方法库与操作系统交互。</li></ol><h1 id="·gc" tabindex="-1"><a class="header-anchor" href="#·gc" aria-hidden="true">#</a> ·GC</h1><p>GC就是垃圾回收，释放堆内存中那些不再被使用的对象的内存。</p><h2 id="确定垃圾" tabindex="-1"><a class="header-anchor" href="#确定垃圾" aria-hidden="true">#</a> 确定垃圾</h2><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h3><p>特点：</p><ol><li>容易产生循环引用问题。</li></ol><h3 id="可达性分析法" tabindex="-1"><a class="header-anchor" href="#可达性分析法" aria-hidden="true">#</a> 可达性分析法</h3><p>实现：</p><ol><li>通过GC Roots Tracing实现。</li><li>以GC Roots作为起点向下搜索。</li><li>不可达的对象将作为垃圾被回收。</li></ol><p>GC Roots：</p><ol><li>虚拟机栈中(局部变量表)的引用。</li><li>本地方法栈中(JNI)的引用。</li><li>方法区中的静态引用/常量引用。</li></ol><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h2><h3 id="标记清除-cms" tabindex="-1"><a class="header-anchor" href="#标记清除-cms" aria-hidden="true">#</a> 标记清除：CMS</h3><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1654780604063-258dd457-20df-445d-ab56-212d28359b80.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>过程：</p>',22)),i("ol",null,[i("li",null,[l[1]||(l[1]=o("标记阶段，对")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[0]||(l[0]=[o("可回收对象")])),_:1}),l[2]||(l[2]=o("进行标记；"))]),i("li",null,[l[4]||(l[4]=o("清除阶段，对标记的对象进行")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[3]||(l[3]=[o("清除")])),_:1}),l[5]||(l[5]=o("，释放它所占用的内存，并取消标记。"))])]),l[305]||(l[305]=i("p",null,"操作：",-1)),i("ol",null,[l[9]||(l[9]=i("li",null,"把对象作为分块。",-1)),l[10]||(l[10]=i("li",null,"把对象连接到“空闲链表”的单向链表上。",-1)),i("li",null,[l[7]||(l[7]=o("之后对")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[6]||(l[6]=[o("新对象进行分配")])),_:1}),l[8]||(l[8]=o("只需要遍历这个空闲链表，就可以找到分块。"))])]),l[306]||(l[306]=d('<p>缺点：</p><ol><li>标记和清除效率不高。</li><li>产生大量内存碎片，无法给大对象分配内存空间。</li></ol><h3 id="标记复制" tabindex="-1"><a class="header-anchor" href="#标记复制" aria-hidden="true">#</a> 标记复制</h3><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1654780973077-6fbeff16-6778-4fe0-85b5-022d88c6a867.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>过程：</p><ol><li>内存划分为大小相等的两块。</li><li>新生成的对象放在区域1，然后当区域1满了，对区域1进行一次标记。</li><li>存活的对象复制到另一块，然后把前一块内存空间进行一次清理。</li></ol><p>特点：</p><ol><li>解决标记清除内存碎片问题。</li><li>只使用了内存的一半。因为同一时刻只有1个内存区域可用。</li></ol><p>例子：</p>',9)),i("ol",null,[l[17]||(l[17]=i("li",null,"HotSpot虚拟机的eden和survivor比例8:1:1，保证内存利用率90%。",-1)),i("li",null,[l[12]||(l[12]=o("minorGC：survivor from+eden存活的对象")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[11]||(l[11]=[o("放到to区")])),_:1}),l[13]||(l[13]=o("，然后survivor From和survivor To互换。"))]),i("li",null,[l[15]||(l[15]=o("如果to区放不下了，需要依靠老年代进行")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[14]||(l[14]=[o("空间分配担保")])),_:1}),l[16]||(l[16]=o("。"))]),l[18]||(l[18]=i("li",null,"也就是借用老年代的空间存储放不下的对象。",-1))]),l[307]||(l[307]=i("h3",{id:"标记整理",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#标记整理","aria-hidden":"true"},"#"),o(" 标记整理")],-1)),l[308]||(l[308]=i("figure",null,[i("img",{src:"https://cdn.nlark.com/yuque/0/2022/png/22839467/1654780619813-80e02dd2-409c-4247-bea2-3c35380cbf3b.png",alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),l[309]||(l[309]=i("p",null,"过程：",-1)),i("ol",null,[i("li",null,[l[20]||(l[20]=o("标记")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[19]||(l[19]=[o("可回收对象")])),_:1}),l[21]||(l[21]=o("。"))]),i("li",null,[l[23]||(l[23]=o("整理阶段：让存活的对象都向")),r(n,{style:{"background-color":"#DEE8FC"}},{default:s(()=>l[22]||(l[22]=[o("一端移动")])),_:1}),l[24]||(l[24]=o("，然后直接清理掉边界以外的内存。"))])]),l[310]||(l[310]=d('<p>特点：</p><ol><li>结合了前两种。</li><li>不会产生内存碎片。</li><li>需要移动大量对象，处理效率比较低。</li></ol><h3 id="分代垃圾回收" tabindex="-1"><a class="header-anchor" href="#分代垃圾回收" aria-hidden="true">#</a> 分代垃圾回收</h3><p>背景：</p><ol><li>上述3种无法对所有类型的对象都进行垃圾回收。</li></ol><p>定义：</p><ol><li>JVM提出的针对不同对象类型。</li><li>采取不同垃圾回收算法。</li></ol><h4 id="分代" tabindex="-1"><a class="header-anchor" href="#分代" aria-hidden="true">#</a> 分代</h4><h5 id="新生代" tabindex="-1"><a class="header-anchor" href="#新生代" aria-hidden="true">#</a> 新生代</h5><p>定义：</p><ol><li>新生成的对象。</li></ol><p>特点：</p><ol><li>对象数量多。</li><li>生命周期短。</li></ol><p>构成：</p><ol><li>eden+survivor From+survivor To</li></ol><h5 id="老年代" tabindex="-1"><a class="header-anchor" href="#老年代" aria-hidden="true">#</a> 老年代</h5><p>定义：</p><ol><li>存放大对象</li><li>存放生命周期长的对象。</li></ol><h4 id="过程" tabindex="-1"><a class="header-anchor" href="#过程" aria-hidden="true">#</a> 过程</h4>',19)),i("h5",b,[l[26]||(l[26]=i("a",{class:"header-anchor",href:"#minorgc","aria-hidden":"true"},"#",-1)),l[27]||(l[27]=o()),r(n,{style:{"background-color":"#FAE1EB"}},{default:s(()=>l[25]||(l[25]=[o("MinorGC")])),_:1})]),l[311]||(l[311]=d("<p>过程：</p><ol><li>大部分情况，对象在eden去分配。</li><li>由于频繁创建对象，内存不足新生代就会触发MinorGC。</li><li>在一次新生代垃圾回收后，eden和survivorFrom中的存活对象，放入survivorTo，对象的年龄增加。</li><li>年龄增加到一定程度默认15岁，会被晋升到老年代。</li><li>清除eden和survivorFrom中的对象。</li><li>survivorTo和suivivorFrom互换，原来在survivorTo成为下一次GC时的survivorFrom。</li></ol><p>特点：</p><ol><li>频繁执行，执行速度也很快。</li></ol>",4)),i("h5",e,[l[29]||(l[29]=i("a",{class:"header-anchor",href:"#fullgc","aria-hidden":"true"},"#",-1)),l[30]||(l[30]=o()),r(n,{style:{"background-color":"#FAE1EB"}},{default:s(()=>l[28]||(l[28]=[o("FullGC")])),_:1})]),l[312]||(l[312]=d('<p>定义：当minorGC后出现老年代且老年代空间不足时会触发MajorGC。</p><p>过程：</p><ol><li>标记清除算法。</li><li>扫描所有对象+标记存活。</li><li>清除未被标记的对象。</li></ol><p>特点：</p><ol><li>耗时较长，很少执行。</li><li>内存碎片。</li></ol><p>触发：</p><ol><li>调用System.gc()，只是建议虚拟机执行，但虚拟机不一定真正去执行。</li><li>老年代空间不足。</li><li>空间分配担保失败。</li><li>Concurrent mode failure。执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性空间不足），便会报ConcurrentModeFailure错误，并触发FullGC。</li></ol><h2 id="四种引用类型" tabindex="-1"><a class="header-anchor" href="#四种引用类型" aria-hidden="true">#</a> 四种引用类型</h2><p>强引用：</p><p>定义：</p><ol><li>把一个对象赋值给一个引用变量时，这个引用变量就是强引用。</li></ol><p>特点：</p><ol><li>java中最常见。</li><li>一定是可达的，所以不会被垃圾回收。</li><li>所以是造成内存泄漏的主要原因。</li></ol><p>软引用：</p><p>定义：</p><ol><li>通过SoftReference类实现。</li></ol><p>特点：</p><ol><li>在系统内存空间不足时被回收。</li></ol><p>弱引用：</p><p>定义：</p><ol><li>通过WeakReference类实现。</li></ol><p>特点：</p><ol><li>垃圾回收时一定会被回收。</li></ol><p>虚引用：</p><p>定义：</p><ol><li>通过PhantomReference类实现。</li></ol><p>作用：</p><ol><li>虚引用和引用队列联合使用。</li><li>用于跟踪对象的垃圾回收状态。</li></ol><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h2><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>新生代：复制</p><ol><li>Serial：单线程复制算法。</li><li>ParNew：多线程复制算法</li><li>Parallel Scavenge：多线程复制算法</li></ol><p>老年代：标记清除/整理</p><ol><li>CMS：多线程标记清除算法</li><li>Serial Old：单线程标记整理算法</li><li>Parallel Old：多线程标记整理算法</li></ol><p>G1：多线程标记整理算法</p><h3 id="并行" tabindex="-1"><a class="header-anchor" href="#并行" aria-hidden="true">#</a> 并行</h3><ol><li>eden内存不足发生MinorGC，标记复制STW</li><li>old内存不足发生fullGC，标记整理STW</li><li>注重吞吐量</li></ol><h3 id="cms" tabindex="-1"><a class="header-anchor" href="#cms" aria-hidden="true">#</a> CMS</h3><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1654781671347-e3782038-9d3c-468c-8a3f-10c66835e367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',39)),i("ol",null,[i("li",null,[l[33]||(l[33]=o("初始标记：仅仅只是标记一下GCRoots能")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[31]||(l[31]=[o("直接关联")])),_:1}),l[34]||(l[34]=o("到的对象，速度很快，需要")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[32]||(l[32]=[o("停顿STW（暂停工作线程）")])),_:1}),l[35]||(l[35]=o("。"))]),i("li",null,[l[39]||(l[39]=o("并发标记：进行GCROOTsTracing的过程，整个回收过程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[36]||(l[36]=[o("耗时")])),_:1}),l[40]||(l[40]=o("最长，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[37]||(l[37]=[o("不需要停顿，")])),_:1}),l[41]||(l[41]=o("和用户线程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[38]||(l[38]=[o("并发一起")])),_:1}),l[42]||(l[42]=o("执行。"))]),i("li",null,[l[45]||(l[45]=o("重新标记：并发标记过程中用户线程继续运行，导致一些对象标记")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[43]||(l[43]=[o("变化")])),_:1}),l[46]||(l[46]=o("，然后重新更新这些标记，需要")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[44]||(l[44]=[o("暂停工作线程")])),_:1}),l[47]||(l[47]=o("。"))]),i("li",null,[l[49]||(l[49]=o("并发清除：和用户线程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[48]||(l[48]=[o("一起")])),_:1}),l[50]||(l[50]=o("执行，不需要停顿，执行清除GC Roots不可达对象。"))])]),l[313]||(l[313]=i("p",null,"并发标记和并发清除是和用户线程一起工作，缩短系统停顿时间。",-1)),l[314]||(l[314]=i("p",null,"缺点：",-1)),i("p",null,[l[53]||(l[53]=o("吞吐量低：")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[51]||(l[51]=[o("低停顿")])),_:1}),l[54]||(l[54]=o("是牺牲吞吐量为代价的，导致")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[52]||(l[52]=[o("CPU利用率不够高")])),_:1}),l[55]||(l[55]=o("。"))]),i("p",null,[l[60]||(l[60]=o("浮动垃圾：4")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[56]||(l[56]=[o("并发清除")])),_:1}),l[61]||(l[61]=o("阶段由于用户线程继续运行可能会产生一定的垃圾，叫做")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[57]||(l[57]=[o("浮动垃圾")])),_:1}),l[62]||(l[62]=o("，这部分垃圾只能到")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[58]||(l[58]=[o("下一次")])),_:1}),l[63]||(l[63]=o("GC时才能进行回收。由于浮动垃圾的存在，需要")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[59]||(l[59]=[o("预留")])),_:1}),l[64]||(l[64]=o("出一部分内存，意味着CMS不能像其他收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现Concurrent mode failure。"))]),i("p",null,[l[66]||(l[66]=o("空间碎片：标记-清除算法导致空间碎片，往往出现空间有剩余但")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[65]||(l[65]=[o("无法找到足够大连续空间来分配对象")])),_:1}),l[67]||(l[67]=o("，不得不提前触发一次fullGC。"))]),l[315]||(l[315]=d('<h3 id="g1" tabindex="-1"><a class="header-anchor" href="#g1" aria-hidden="true">#</a> G1</h3><p>定义：</p><ol><li>将内存划分为大小固定的一些独立区域。</li><li>每个区域都可以作为新生代和老年代。</li><li>区域独立使用资源以及垃圾回收。</li><li>维护优先级列表，根据系统允许的最长垃圾收集时间，优先回收垃圾最多的区域。</li></ol><p>作用：</p><ol><li>避免全区域垃圾收集引起系统停顿。</li><li>能够确保有限时间内获得最高的垃圾收集效率。</li></ol><p>特点：</p><ol><li>基于标记整理算法，不产生内存碎片。</li><li>可以控制停顿时间，既能够保证时间短，又能够保证收集的效率。</li></ol>',7)),r(n,{style:{"background-color":"#E4F7D2"}},{default:s(()=>l[68]||(l[68]=[o("RememberSet")])),_:1}),l[316]||(l[316]=i("p",null,"定义：",-1)),i("ol",null,[i("li",null,[l[70]||(l[70]=o("用来记录每个区域对象的")),r(n,{style:{"background-color":"#FFE8E6"}},{default:s(()=>l[69]||(l[69]=[o("引用对象")])),_:1}),l[71]||(l[71]=o("所在的区域。"))])]),l[317]||(l[317]=i("p",null,"作用：",-1)),i("ol",null,[i("li",null,[l[73]||(l[73]=o("在做可达性分析时可以")),r(n,{style:{"background-color":"#FFE8E6"}},{default:s(()=>l[72]||(l[72]=[o("避免")])),_:1}),l[74]||(l[74]=o("全堆扫描。"))]),i("li",null,[l[76]||(l[76]=o("尤其是老年代也存在一些GCROOT节点，但是老年代数据相对较多，如果遍历寻找会很耗时，可以通过RememberSet去找")),r(n,{style:{"background-color":"#FFE8E6"}},{default:s(()=>l[75]||(l[75]=[o("引用的对象")])),_:1}),l[77]||(l[77]=o("节点。"))])]),l[318]||(l[318]=i("figure",null,[i("img",{src:"https://cdn.nlark.com/yuque/0/2022/png/22839467/1654781897124-da755609-14ca-4576-afa7-b91d15bc0a02.png",alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),i("ol",null,[i("li",null,[l[81]||(l[81]=o("初始标记：与CMS一样。仅仅只是标记一下GCRoots能")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[78]||(l[78]=[o("直接关联")])),_:1}),l[82]||(l[82]=o("到的对象，速度很快，需要")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[79]||(l[79]=[o("停顿STW")])),_:1}),l[83]||(l[83]=o("，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[80]||(l[80]=[o("单线程")])),_:1}),l[84]||(l[84]=o("。"))]),i("li",null,[l[89]||(l[89]=o("并发标记：和CMS一样。进行GCROOTsTracing的过程，他在整个回收过程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[85]||(l[85]=[o("耗时")])),_:1}),l[90]||(l[90]=o("最长，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[86]||(l[86]=[o("不需要停顿")])),_:1}),l[91]||(l[91]=o("，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[87]||(l[87]=[o("单线程")])),_:1}),l[92]||(l[92]=o("，和用户线程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[88]||(l[88]=[o("并发")])),_:1}),l[93]||(l[93]=o("执行。"))]),i("li",null,[l[96]||(l[96]=o("最终标记：与CMS差不多，最终标记的区别在于虚拟机将在并发标记时标记变化对象")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[94]||(l[94]=[o("记录在")])),_:1}),l[97]||(l[97]=o("线程的RememberSetLogs里面，然后把RememberedSetLogs的数据")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[95]||(l[95]=[o("合并到")])),_:1}),l[98]||(l[98]=o("RememberSet中。这阶段需要STW，但是多线程执行最终标记。"))]),i("li",null,[l[103]||(l[103]=o("筛选回收：首先对各个区域的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[99]||(l[99]=[o("回收价值")])),_:1}),l[104]||(l[104]=o("和")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[100]||(l[100]=[o("成本")])),_:1}),l[105]||(l[105]=o("进行排序，根据用户")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[101]||(l[101]=[o("期望")])),_:1}),l[106]||(l[106]=o("的GC")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[102]||(l[102]=[o("停顿时间")])),_:1}),l[107]||(l[107]=o("来指定回收计划。"))])]),l[319]||(l[319]=i("p",null,"YoungGC：",-1)),l[320]||(l[320]=i("p",null,"定义：",-1)),l[321]||(l[321]=i("ol",null,[i("li",null,"Eden区满了可能触发。"),i("li",null,"会先去计算一下回收这个Eden区的时间。"),i("li",null,"如果远远小于先前设定的期望停顿时间，说明现在Eden区太小了，垃圾并不多，不需要触发youngGC。"),i("li",null,"会新增一些Eden区。直到计算的回收时间到达一定程度才会去真的触发youngGC。")],-1)),l[322]||(l[322]=i("p",null,"MixGC：",-1)),l[323]||(l[323]=i("p",null,"定义：",-1)),i("ol",null,[i("li",null,[l[109]||(l[109]=o("老年代所占")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[108]||(l[108]=[o("比例大于")])),_:1}),l[110]||(l[110]=o("等于设定的比例了，就会触发MixGC。"))]),i("li",null,[l[113]||(l[113]=o("会回收")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[111]||(l[111]=[o("所有的年轻代")])),_:1}),l[114]||(l[114]=o("和")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[112]||(l[112]=[o("部分老年代")])),_:1}),l[115]||(l[115]=o("。"))]),i("li",null,[r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[116]||(l[116]=[o("根据最大的停顿")])),_:1}),l[117]||(l[117]=o("时间，计算回收效益比，决定回收哪些区域。"))])]),l[324]||(l[324]=i("p",null,"特点：",-1)),l[325]||(l[325]=i("ol",null,[i("li",null,"和CMS的Full GC类似。")],-1)),l[326]||(l[326]=i("p",null,"FullGC：",-1)),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[118]||(l[118]=[o("定义：")])),_:1}),l[327]||(l[327]=d('<ol><li>在进行复制算法的时候，没有更多的空间供你复制的时候，就会触发fullGC。</li></ol><p>特点：</p><ol><li>整个程序停止。</li></ol><h3 id="zgc" tabindex="-1"><a class="header-anchor" href="#zgc" aria-hidden="true">#</a> ZGC</h3><ol><li>JDK11引入的一个收集器。</li><li>特点不采用分代回收的机制。</li><li>使用了读屏障、染色指针和内存多重映射技术实现的。</li><li>可并发+标记整理算法。</li></ol><p>内存分布：区域叫做region，小型+中型+大型</p><p>染色指针：</p>',7)),i("ol",null,[l[122]||(l[122]=i("li",null,"染色指针是一个指向对象的指针，存储一些额外的信息。",-1)),l[123]||(l[123]=i("li",null,"比如通过指针上的一些标志位看到引用对象的状态。",-1)),l[124]||(l[124]=i("li",null,"可以通过指针，在内存清除的时候能够立即释放内存。",-1)),i("li",null,[l[120]||(l[120]=o("设置")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[119]||(l[119]=[o("内存屏障")])),_:1}),l[121]||(l[121]=o("可以记录对象引用的变更情况，这些信息可以记录在染色指针中。"))]),l[125]||(l[125]=i("li",null,"所以可以减少使用内存屏障的数量。",-1)),l[126]||(l[126]=i("li",null,"通过染色指针记录信息、数据可以提高性能。",-1))]),l[328]||(l[328]=d('<h1 id="·java内存模型" tabindex="-1"><a class="header-anchor" href="#·java内存模型" aria-hidden="true">#</a> ·Java内存模型</h1><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/22839467/1654782622698-d29c6c36-d3dd-42d3-b8ae-98584e44608c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>jdk1.6：栈内存（本地方法栈、虚拟机栈、程序计数器）这部分也是线程私有的，线程共享的是包括堆内存，方法区（常量池）</p><p>jdk1.7：把字符串常量池搬到了堆中。</p><p>jdk1.8：取消了方法区，方法区变成了元空间，放在直接内存中。也是包括运行时常量池和类常量池。</p><p>注：静态对象1.8在堆中，早期在方法区。</p><h2 id="栈区【私有】" tabindex="-1"><a class="header-anchor" href="#栈区【私有】" aria-hidden="true">#</a> 栈区【私有】</h2><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h3><p>定义：很小的内存空间。存储当前运行线程字节码运行到哪的行号。</p><p>作用：</p>',10)),i("ol",null,[i("li",null,[l[128]||(l[128]=o("程序控制：解释器通过改变程序计数器读取字节码，实现代码的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[127]||(l[127]=[o("流程控制")])),_:1}),l[129]||(l[129]=o("。顺序、选择、循环。"))]),i("li",null,[l[131]||(l[131]=o("线程切换：线程被")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[130]||(l[130]=[o("切换，")])),_:1}),l[132]||(l[132]=o("回来的时候能知道线程上次运行到哪了。"))])]),l[329]||(l[329]=i("p",null,"特征：",-1)),i("ol",null,[i("li",null,[l[135]||(l[135]=o("程序计数器是唯一")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[133]||(l[133]=[o("不会")])),_:1}),l[136]||(l[136]=o("出现")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[134]||(l[134]=[o("OOM")])),_:1}),l[137]||(l[137]=o("的内存区域。"))]),i("li",null,[l[139]||(l[139]=o("是线程私有的，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[138]||(l[138]=[o("生命周期")])),_:1}),l[140]||(l[140]=o("随线程的创建而创建，随线程的结束而死亡。"))])]),l[330]||(l[330]=i("h3",{id:"虚拟机栈",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#虚拟机栈","aria-hidden":"true"},"#"),o(" 虚拟机栈")],-1)),l[331]||(l[331]=i("p",null,"作用：描述java的方法的执行过程的内存区域。",-1)),l[332]||(l[332]=i("p",null,"过程：",-1)),i("ol",null,[i("li",null,[l[144]||(l[144]=o("每个java")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[141]||(l[141]=[o("方法")])),_:1}),l[145]||(l[145]=o("在执行时会创建一个")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[142]||(l[142]=[o("栈帧")])),_:1}),l[146]||(l[146]=o("用于存储")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[143]||(l[143]=[o("局部变量表")])),_:1}),l[147]||(l[147]=o("，操作数栈，动态链接，方法出口等信息。"))]),i("li",null,[l[151]||(l[151]=o("方法")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[148]||(l[148]=[o("调用")])),_:1}),l[152]||(l[152]=o("直至执行完成，对应着一个栈帧在java虚拟机栈中")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[149]||(l[149]=[o("入栈")])),_:1}),l[153]||(l[153]=o("和")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[150]||(l[150]=[o("出栈")])),_:1}),l[154]||(l[154]=o("的过程。"))])]),l[333]||(l[333]=d('<p>存储的东西定义：</p><ol><li>局部变量表主要存放了编译器可知的基本数据类型数据（boolean，byte，char，short，int，float，long，double）、对象引用。</li><li>操作数栈用于局部变量表中的数据做一些运算。</li></ol><h3 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h3><p>作用：虚拟机栈为java方法服务；本地方法栈为native方法服务。</p><p>特点：和虚拟机栈发挥的作用相似。</p><h2 id="【共享】" tabindex="-1"><a class="header-anchor" href="#【共享】" aria-hidden="true">#</a> 【共享】</h2><h3 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h3><p>定义：存放运行过程中创建的对象和产生的数据。</p><p>特点：</p><ol><li>存放几乎所有对象实例和数组。</li><li>垃圾收集器进行垃圾回收的主要内存区域。</li></ol><p>包括：</p><ol><li>新生代1/3+老年代2/3</li><li>新生代=eden8/10+from survivor1/10+to survivor1/10</li></ol><p>如何回收：</p><p>minorGC：</p><ol><li>大部分情况，对象在eden去分配。</li><li>由于频繁创建对象，内存不足新生代就会触发MinorGC。</li><li>在一次新生代垃圾回收后，eden和survivorFrom中的存活对象，放入survivorTo，对象的年龄增加。</li><li>年龄增加到一定程度默认15岁，会被晋升到老年代。</li><li>情况eden和survivorFrom中的对象。</li><li>survivorTo和suivivorFrom互换，原来在survivorTo成为下一次GC时的survivorFrom。</li></ol><p>老年代的年龄阈值：-XX:MaxTenuringThreshold来设置。</p><p>MajorGC：</p><p>定义：当minorGC后出现老年代且老年代空间不足时会触发MajorGC。</p><p>过程：</p><ol><li>标记清除算法。</li><li>扫描所有对象+标记存活。</li><li>清除未被标记的对象。</li></ol><p>特点：</p><ol><li>耗时较长。</li><li>内存碎片。</li></ol><h3 id="方法区-永久代" tabindex="-1"><a class="header-anchor" href="#方法区-永久代" aria-hidden="true">#</a> 方法区（永久代）</h3><p>定义：</p><ol><li>存储运行时常量池；</li><li>静态变量、类信息；</li><li>存储常量；</li><li>即时编译器编译后的机器码。</li></ol><p>运行时常量池：</p>',26)),i("ol",null,[i("li",null,[l[158]||(l[158]=o("是方法区的一部分，用于存放")),r(n,{style:{"background-color":"#E4F7D2"}},{default:s(()=>l[155]||(l[155]=[o("编译器生成")])),_:1}),l[159]||(l[159]=o("的各种")),r(n,{style:{"background-color":"#E4F7D2"}},{default:s(()=>l[156]||(l[156]=[o("字面量")])),_:1}),l[160]||(l[160]=o("和")),r(n,{style:{"background-color":"#E4F7D2"}},{default:s(()=>l[157]||(l[157]=[o("符号引用")])),_:1}),l[161]||(l[161]=o("。"))]),l[162]||(l[162]=i("li",null,"受限于方法区内存，也会OOM。",-1))]),r(n,{style:{"background-color":"#E4F7D2"}},{default:s(()=>l[163]||(l[163]=[o("永久代的实现")])),_:1}),l[334]||(l[334]=o("从方法区替换为元空间：")),l[335]||(l[335]=i("ol",null,[i("li",null,"因为永久代的空间有限，大量使用字符串的场景下会导致OOM错误。"),i("li",null,"永久代有一个jvm本身设定的固定大小上限，无法进行调整。而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会OOM。可以使用-XX:MaxMetaspaceSize标志设置最大元空间大小。")],-1)),l[336]||(l[336]=i("figure",null,[i("img",{src:"https://cdn.nlark.com/yuque/0/2022/png/22839467/1654782913117-24777e19-1461-4163-a253-67125cd6e9be.png",alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),l[337]||(l[337]=i("h2",{id:"直接内存",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#直接内存","aria-hidden":"true"},"#"),o(" 直接内存")],-1)),l[338]||(l[338]=i("p",null,"定义：",-1)),i("ol",null,[i("li",null,[l[165]||(l[165]=o("叫堆外内存，直接内存")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[164]||(l[164]=[o("并不是jvm")])),_:1}),l[166]||(l[166]=o("运行时数据区的一部分。"))])]),l[339]||(l[339]=i("p",null,"特点：",-1)),i("ol",null,[l[169]||(l[169]=i("li",null,"这部分内存也会被频繁使用。",-1)),i("li",null,[r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[167]||(l[167]=[o("可能导致OOM")])),_:1}),l[168]||(l[168]=o("Error异常出现，受本机总内存大小限制。"))]),l[170]||(l[170]=i("li",null,"大小不受java堆的限制。",-1))]),l[340]||(l[340]=d('<p>比如：</p><ol><li>jdk1.4中NIO类，基于通道Channel和缓存区Buffer的IO操作方式就是基于堆外内存实现的。</li><li>它可以直接使用native函数本地方法库进行堆外内存分配。</li><li>通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</li></ol><p>好处：</p><ol><li>避免了在java堆和内核之间来回复制数据。</li><li>还能在一些场景中提高性能。</li></ol><h2 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h2><p>结论：</p><ol><li>java的对象不一定在堆上分配。</li></ol><p>作用：</p><ol><li>JVM通过逃逸分析，分析出一个对象的使用范围。</li><li>并确定是否将这个对象分配在堆上。</li></ol><p>过程：</p><ol><li>如果有些对象没有逃逸出方法，那么可能会被优化在栈上分配。</li></ol><p>举例：</p>',12)),i("ol",null,[i("li",null,[l[174]||(l[174]=o("对象")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[171]||(l[171]=[o("被赋值")])),_:1}),l[175]||(l[175]=o("给了一些")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[172]||(l[172]=[o("成员变量")])),_:1}),l[176]||(l[176]=o("，那么这个成员变量可能被外部的方法使用，此时变量发生了逃逸，只能在")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[173]||(l[173]=[o("堆")])),_:1}),l[177]||(l[177]=o("上分配。"))]),i("li",null,[l[181]||(l[181]=o("另一种场景就是对象通过")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[178]||(l[178]=[o("return语句")])),_:1}),l[182]||(l[182]=o("返回了对象，程序不能确定后续这个对象会不会")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[179]||(l[179]=[o("被使用")])),_:1}),l[183]||(l[183]=o("，外部的方法（线程）可能会")),r(n,{style:{"background-color":"#FADB14"}},{default:s(()=>l[180]||(l[180]=[o("访问")])),_:1}),l[184]||(l[184]=o("到这个变量，也发生了逃逸。"))])]),l[341]||(l[341]=d(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectEscape</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectReturn</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="·类加载机制" tabindex="-1"><a class="header-anchor" href="#·类加载机制" aria-hidden="true">#</a> ·类加载机制</h1><p>定义：</p><ol><li>把字节码文件加载到JVM中。</li><li>创建对应的Class对象。</li></ol>`,4)),i("h2",g,[l[186]||(l[186]=i("a",{class:"header-anchor",href:"#加载","aria-hidden":"true"},"#",-1)),l[187]||(l[187]=o()),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[185]||(l[185]=[o("加载")])),_:1})]),l[342]||(l[342]=i("p",null,"过程：",-1)),i("ol",null,[i("li",null,[l[189]||(l[189]=o("读取类的字节码文件")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[188]||(l[188]=[o("转换")])),_:1}),l[190]||(l[190]=o("成字节流存入方法区中。"))]),i("li",null,[l[192]||(l[192]=o("在堆中")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[191]||(l[191]=[o("创建")])),_:1}),l[193]||(l[193]=o("一个对应的Class对象。"))])]),l[343]||(l[343]=i("p",null,"特征：",-1)),l[344]||(l[344]=i("ol",null,[i("li",null,"先加载父类，懒惰加载。")],-1)),l[345]||(l[345]=i("h2",{id:"链接",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#链接","aria-hidden":"true"},"#"),o(" 链接")],-1)),i("h3",E,[l[195]||(l[195]=i("a",{class:"header-anchor",href:"#验证","aria-hidden":"true"},"#",-1)),l[196]||(l[196]=o()),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[194]||(l[194]=[o("验证")])),_:1})]),l[346]||(l[346]=i("p",null,"定义：",-1)),l[347]||(l[347]=i("ol",null,[i("li",null,"验证Class文件的规范性，是否符合当前虚拟机的要求。")],-1)),l[348]||(l[348]=i("p",null,"验证内容：",-1)),l[349]||(l[349]=i("ol",null,[i("li",null,"文件格式：是否符合Class文件字节流的规范。"),i("li",null,"元数据验证：符合java语言规范。"),i("li",null,"字节码验证：确保程序符合逻辑的。"),i("li",null,"符号引用验证：确保解析动作能正确执行。")],-1)),i("h3",C,[l[198]||(l[198]=i("a",{class:"header-anchor",href:"#准备","aria-hidden":"true"},"#",-1)),l[199]||(l[199]=o()),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[197]||(l[197]=[o("准备")])),_:1})]),i("ol",null,[i("li",null,[l[201]||(l[201]=o("为")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[200]||(l[200]=[o("类变量")])),_:1}),l[202]||(l[202]=o("初始化并赋值"))]),i("li",null,[l[204]||(l[204]=o("（但是赋的值并不是用户期望的值，而是")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[203]||(l[203]=[o("默认")])),_:1}),l[205]||(l[205]=o("值）。"))]),i("li",null,[l[209]||(l[209]=o("但是对于")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[206]||(l[206]=[o("final")])),_:1}),l[210]||(l[210]=o("修饰的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[207]||(l[207]=[o("static")])),_:1}),l[211]||(l[211]=o("变量会被初始化成")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[208]||(l[208]=[o("用户期望")])),_:1}),l[212]||(l[212]=o("的值。"))])]),i("h3",k,[l[214]||(l[214]=i("a",{class:"header-anchor",href:"#解析","aria-hidden":"true"},"#",-1)),l[215]||(l[215]=o()),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[213]||(l[213]=[o("解析")])),_:1})]),i("ol",null,[i("li",null,[l[219]||(l[219]=o("将")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[216]||(l[216]=[o("常量")])),_:1}),l[220]||(l[220]=o("池中的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[217]||(l[217]=[o("符号引用")])),_:1}),l[221]||(l[221]=o("替换为")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[218]||(l[218]=[o("直接引用")])),_:1}),l[222]||(l[222]=o("的过程。"))]),l[223]||(l[223]=i("li",null,"符号引用：就是一个符号，而不指向真实的对象。",-1)),l[224]||(l[224]=i("li",null,"直接引用：是指向真实的地址引用。",-1))]),i("h2",y,[l[226]||(l[226]=i("a",{class:"header-anchor",href:"#初始化","aria-hidden":"true"},"#",-1)),l[227]||(l[227]=o()),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[225]||(l[225]=[o("初始化")])),_:1})]),i("ol",null,[i("li",null,[l[230]||(l[230]=o("执行")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[228]||(l[228]=[o("静态代码块")])),_:1}),l[231]||(l[231]=o("，为静态变量")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[229]||(l[229]=[o("赋真实值")])),_:1}),l[232]||(l[232]=o("的过程。"))]),l[233]||(l[233]=i("li",null,"赋值有两种方式，一种是声明变量时直接赋值，一种是静态代码块赋值。",-1))]),l[350]||(l[350]=i("p",null,"使用这个类会触发类的加载：几种方式",-1)),i("ol",null,[i("li",null,[l[235]||(l[235]=o("创建类的实例，也就是")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[234]||(l[234]=[o("new")])),_:1}),l[236]||(l[236]=o("的方式"))]),i("li",null,[l[238]||(l[238]=o("访问某个类或接口的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[237]||(l[237]=[o("静态变量")])),_:1}),l[239]||(l[239]=o("，或者对静态变量赋值。"))]),i("li",null,[l[241]||(l[241]=o("调用类的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[240]||(l[240]=[o("静态方法")])),_:1}),l[242]||(l[242]=o("。"))]),l[249]||(l[249]=i("li",null,"反射(Class.forName())",-1)),i("li",null,[l[244]||(l[244]=o("初始化某个类的子类，会")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[243]||(l[243]=[o("触发父类")])),_:1}),l[245]||(l[245]=o("的加载。"))]),i("li",null,[l[247]||(l[247]=o("Java虚拟机启动时被标注为")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[246]||(l[246]=[o("启动类")])),_:1}),l[248]||(l[248]=o("的类，直接使用java.exe命令运行某个类。"))])]),l[351]||(l[351]=i("p",null,"调试工具：jhsdb.exe hsdb。",-1)),l[352]||(l[352]=i("h2",{id:"双亲委派",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#双亲委派","aria-hidden":"true"},"#"),o(" 双亲委派")],-1)),i("p",null,[l[253]||(l[253]=o("加载类的时候会优先委派")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[250]||(l[250]=[o("上级类加载器")])),_:1}),l[254]||(l[254]=o("对这个类进行加载，如果上级能够找到这个类，就由上级加载，上级对下级可见。否则就由")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[251]||(l[251]=[o("下级")])),_:1}),l[255]||(l[255]=o("加载，好处就是能优先")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[252]||(l[252]=[o("加载核心类")])),_:1}),l[256]||(l[256]=o("。"))]),l[353]||(l[353]=d('<p>Jdk8中的类加载器：</p><ol><li>Bootstrap Classloader: 启动类加载器，主要加载java的核心类库 java_home/jre/lib目录下jar和class</li><li>Extension classloader：扩展类加载器 java_home/jre/lib/ext下的jar和class</li><li>Application classloader: 当前应用的classpath下的所有类。</li><li>再下面是用户自定义加载器。</li></ol><p>举例：</p><ol><li>加载String.class 上到bootstrap classloader可以加载</li><li>如果包名为java.开头会报错，抛出SecurityException。自定义类加载器也不行。</li><li>如果包名java.lang，编译都通不过。</li></ol><p>实现代码：loadClass方法</p><ol><li>先检查类是否已经被加载过</li><li>如果没有加载调用父加载器的loadClass方法进行加载。</li><li>如果父加载器失败，那么会调用自己的findClass方法进行加载</li></ol><h3 id="为什么用双亲委派" tabindex="-1"><a class="header-anchor" href="#为什么用双亲委派" aria-hidden="true">#</a> 为什么用双亲委派？</h3><ol><li>更安全，优先加载核心类。比如某些类只会由Bootstrap类加载器加载，加载的目录是lib下面的类，如果自己写一个重名的类那么是不会被加载。</li><li>避免重复加载，当父亲已经加载了该类的时候，子类加载器就不会再加载一次。</li><li>如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患。</li><li>而双亲委派的方式，就可以避免这种情况。因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载。</li><li>所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</li></ol><h3 id="破坏双亲委派" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派" aria-hidden="true">#</a> 破坏双亲委派</h3><ol><li>双亲委派实现是在loadClass方法里实现的。</li><li>那么想要破坏双亲委派我们可以自定义一个类加载器，继承ClassLoader。</li><li>重写里面的loadClass方法，让他不进行双亲委派。</li><li>破坏双亲委派可以实现自定义类String的加载，但是包名不能是java.lang。可以是com.xxx.String.</li></ol><h3 id="如何自定义类加载器【不破坏双亲委派】" tabindex="-1"><a class="header-anchor" href="#如何自定义类加载器【不破坏双亲委派】" aria-hidden="true">#</a> 如何自定义类加载器【不破坏双亲委派】</h3><ol><li>我们继承ClassLoader。</li><li>重写findClass方法，而不是覆盖loadClass方法。</li><li>因为在loadClass方法中，如果父类加载器加载失败会调用findClass方法来完成加载。</li><li>然后再findClass方法中实现自己的加载逻辑即可。</li></ol><h3 id="破坏双亲委派的例子" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派的例子" aria-hidden="true">#</a> 破坏双亲委派的例子</h3><ol><li>JNDI，JDBC等需要加载SPI接口实现类的情况。 <ol><li>比如JDBC用于创建数据库连接的代码。Connection conn=DriverManager.getConnection(&quot;jdbc://mysql://localhost:3306/mysql&quot;,&quot;root&quot;,&quot;1234&quot;);</li><li>DriverManage是会Bootstrap类加载器加载的。</li><li>在类加载时，会执行类的静态方法。静态方法里会有一行代码，会去尝试加载classpath下面所有实现了Driver接口的实现类。</li><li>那么这些类是不能被bootstrap类加载器加载的。</li><li>JDBC就引入ThreadContextClassLoad的方式破坏了双亲委派。</li></ol></li><li>实现热插拔热部署的工具。在代码启动后修改代码无需重启。实现方式就是连同类加载器一起换掉实现代码的热部署。比如idea中有一个插件jrable。</li><li>tomcat等web容器。 <ol><li>tomcat部署可能需要部署多个应用。</li><li>就有一个问题，不同的应用可能依赖的jar包的版本是不同的，但是路径却是一样的。</li><li>如果采用默认的类加载机制，是无法加载多个相同的类。</li><li>tomcat提供了一种隔离机制，为每个web容器单独提供了一个类加载器。webAppClassLoader。</li><li>优先加载web应用自己定义的类。也就是本目录下的class文件。</li><li>如果加载不到在交给上级类加载器加载。和双亲委派是相反的。</li></ol></li></ol><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><h3 id="_1-jvm在搜索类时-如何判定两个class是相同的呢" tabindex="-1"><a class="header-anchor" href="#_1-jvm在搜索类时-如何判定两个class是相同的呢" aria-hidden="true">#</a> 1. JVM在搜索类时，如何判定两个class是相同的呢？</h3>',16)),r(n,{style:{color:"rgb(232,50,60)"}},{default:s(()=>l[257]||(l[257]=[o("JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。")])),_:1}),l[354]||(l[354]=d('只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成一个字节码文件NetClassLoaderSimple.class，假如ClassLoaderA和ClassLoaderB这两个类加载器分别读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。<h1 id="·jvm参数-泄漏-调优" tabindex="-1"><a class="header-anchor" href="#·jvm参数-泄漏-调优" aria-hidden="true">#</a> ·JVM参数/泄漏/调优</h1><h2 id="jvm内存参数" tabindex="-1"><a class="header-anchor" href="#jvm内存参数" aria-hidden="true">#</a> JVM内存参数</h2><p>-Xmx最大分配的堆内存大小，  Java Heap 最大值，默认值为物理内存的1/4 ；</p><p>-Xms初始化的堆大小，Java Heap 初始值，设置这两个成相同大小，避免在程序运行时堆不够用时要动态扩展，并且尽可能的使用最大的堆大小，可以减少GC时间。<br> -Xmn    Java Heap Young 区大小，不熟悉最好保留默认值；<br> -Xss      每个线程的Stack 大小，不熟悉最好保留默认值；<br> -XX:PermSize ：设定内存的永久保存区域；<br> -XX:MaxPermSize ：设定最大内存的永久保存区域；<br> -XX:PermSize ：设定内存的永久保存区域；<br> -XX:NewSize ：设置JVM 堆的‘新生代’的默认大小；<br> -XX:MaxNewSize ：设置JVM 堆的‘新生代’的最大大小；</p><p>-XX:PretenureSizeThreshold:当对象大于某一个值时直接放入老年代，减少了新生代和老年代之间的复制操作，一般设置为和数据集差不多的大小。因为由数据集在整个程序生命周期中基本都会用到的，直到最后的测试评估。</p><p>-XX:-UseBiasedLocking=false对于多并发访问的代码块，关闭对象的偏向锁，这样程序里边同步代码块里边的偏向锁就被关闭了，减少了性能的损耗。</p><h2 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏" aria-hidden="true">#</a> 内存泄漏</h2><p>1、静态集合类，如hashmap、linkedlist等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><p>2、各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close()方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性的关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><p>3、变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其适用范围，很有可能会造成内存泄漏，另一方面，如果没有及时把对象设置为null，很有可能导致内存泄漏的发生。</p><p>4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><p>5、改变哈希值。当一个对象被存储进hashset集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进hashset集合中时的哈希值就不同了，在这种情况下，即使contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p><p>7、缓存泄漏。内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><h2 id="jvm调优" tabindex="-1"><a class="header-anchor" href="#jvm调优" aria-hidden="true">#</a> JVM调优</h2><p>对于还在正常运行的系统</p>',16)),i("ol",null,[i("li",null,[l[260]||(l[260]=o("可以使用")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[258]||(l[258]=[o("jmap")])),_:1}),l[261]||(l[261]=o("来查看JVM中")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[259]||(l[259]=[o("各个区域")])),_:1}),l[262]||(l[262]=o("的使用情况。"))])]),l[355]||(l[355]=i("p",null,"通过jmap命令查看堆中对象jmap -histo:live 7869 | head -20定位前20个",-1)),i("ol",v,[i("li",null,[l[267]||(l[267]=o("可以通过")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[263]||(l[263]=[o("jstack")])),_:1}),l[268]||(l[268]=o("查看")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[264]||(l[264]=[o("线程的运行")])),_:1}),l[269]||(l[269]=o("情况，比如哪些线程")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[265]||(l[265]=[o("阻塞")])),_:1}),l[270]||(l[270]=o("，是否出现了")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[266]||(l[266]=[o("死锁")])),_:1})])]),l[356]||(l[356]=i("p",null,"Jstack -l 26045 > ./26045.stack",-1)),l[357]||(l[357]=i("p",null,"Cat 26045.stack | grep ‘65be’ -C 20",-1)),i("ol",F,[i("li",null,[i("p",null,[l[273]||(l[273]=o("可以通过")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[271]||(l[271]=[o("jstat")])),_:1}),l[274]||(l[274]=o("命令查看")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[272]||(l[272]=[o("垃圾回收")])),_:1}),l[275]||(l[275]=o("的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了"))])]),i("li",null,[i("p",null,[l[277]||(l[277]=o("通过各个命令的结果，或者")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[276]||(l[276]=[o("JVisualVM")])),_:1}),l[278]||(l[278]=o("等工具来进行分析"))])]),i("li",null,[i("p",null,[l[282]||(l[282]=o("首先，初步猜测频繁发送fullgc的原因，如果")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[279]||(l[279]=[o("频繁发生fullgc")])),_:1}),l[283]||(l[283]=o("但是又一直")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[280]||(l[280]=[o("没有出现内存溢出")])),_:1}),l[284]||(l[284]=o("，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[281]||(l[281]=[o("尝试加大年轻代的大小")])),_:1}),l[285]||(l[285]=o("，如果改完之后，fullgc减少，则证明修改有效。"))])]),l[286]||(l[286]=i("li",null,[i("p",null,"同时，还可以找到占用cpu最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存。")],-1))]),l[358]||(l[358]=i("p",null,"对于已经发生了OOM的系统：",-1)),i("ol",null,[l[303]||(l[303]=i("li",null,[i("p",null,"一般生产系统中都会设置当系统发生了OOM，生成当时的dump文件（-X +HeapDumpOnOutOfMemoryError-XXHeapDumpPath=/usr/local/base）")],-1)),i("li",null,[i("p",null,[l[289]||(l[289]=o("我们可以利用")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[287]||(l[287]=[o("JVisualVM")])),_:1}),l[290]||(l[290]=o("等工具来分析")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[288]||(l[288]=[o("dump文件")])),_:1})])]),i("li",null,[i("p",null,[l[295]||(l[295]=o("根据dump文件找到")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[291]||(l[291]=[o("异常的实例对象")])),_:1}),l[296]||(l[296]=o("和")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[292]||(l[292]=[o("异常的线程")])),_:1}),l[297]||(l[297]=o("（占用CPU高），")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[293]||(l[293]=[o("定位")])),_:1}),l[298]||(l[298]=o("到具体的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[294]||(l[294]=[o("代码")])),_:1})])]),i("li",null,[i("p",null,[l[301]||(l[301]=o("然后在进行详细的")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[299]||(l[299]=[o("分析")])),_:1}),l[302]||(l[302]=o("和")),r(n,{style:{"background-color":"#D4EEFC"}},{default:s(()=>l[300]||(l[300]=[o("调试")])),_:1})])])]),l[359]||(l[359]=i("p",null,"总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析、最终定位到具体的问题。",-1)),l[360]||(l[360]=i("p",null,"cpu100%",-1)),l[361]||(l[361]=i("ol",null,[i("li",null,"top找到占用率高的进程"),i("li",null,"top -Hp pid找到CPU占用高的线程ID"),i("li",null,'线程id转换为16进制，printf "0x%x\\n" 958，得到0X3be'),i("li",null,"通过命令jstack 163 | grep '0x3be' -C5 --color或者jstack 163 | vim +0x3be-")],-1))])}const M=t(f,[["render",m],["__file","jvm.html.vue"]]);export{M as default};
