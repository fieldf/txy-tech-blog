const l=JSON.parse('{"key":"v-aca788a4","path":"/tech/java/juc.html","title":"JUC","lang":"zh-CN","frontmatter":{"title":"JUC","date":"2023-02-12T00:00:00.000Z","index":false,"icon":"laptop-code","category":["JUC"],"tag":["多线程","线程池","锁"],"description":"·线程 1线程 线程生命周期 锁池和等待池 Java中的对象有两个池，对对象加synchronized锁时必须获得对象锁，没有获得锁的线程进入锁池。获取到锁的线程如果调用了wait()方法就会进入等待池，进入等待池的线程不会竞争对象锁。 状态： 新建New：new新建一个线程，处于新建状态。为线程分配内存并初始化成员变量的值。 就绪Runnable：可运行态。start启动一个线程，处于就绪状态。 运行Running：获取CPU资源后，执行run方法进入运行状态。 阻塞Blocked 同步阻塞：运行线程尝试获取同步锁没有获取到，JVM会把线程放入锁池。 其他阻塞：运行线程执行sleep、I/O阻塞（等待用户输入），JVM会把线程转入阻塞状态。 waiting状态： 调用wait方法，进入waiting状态，会释放对象锁。被notify唤醒会变为runnable状态，被唤醒是从等待池进入锁池重新竞争锁，状态其实是blocked。获取到锁以后才是runnable。 调用join方法，也会让调用join的线程从runnable变成waiting。 死亡Dead：处于运行状态的线程调用run方法或call方法执行完成后、调用stop方法停止线程、程序执行错误/异常退出，进入死亡状态。","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/tech/java/juc.html"}],["meta",{"property":"og:site_name","content":"txy"}],["meta",{"property":"og:title","content":"JUC"}],["meta",{"property":"og:description","content":"·线程 1线程 线程生命周期 锁池和等待池 Java中的对象有两个池，对对象加synchronized锁时必须获得对象锁，没有获得锁的线程进入锁池。获取到锁的线程如果调用了wait()方法就会进入等待池，进入等待池的线程不会竞争对象锁。 状态： 新建New：new新建一个线程，处于新建状态。为线程分配内存并初始化成员变量的值。 就绪Runnable：可运行态。start启动一个线程，处于就绪状态。 运行Running：获取CPU资源后，执行run方法进入运行状态。 阻塞Blocked 同步阻塞：运行线程尝试获取同步锁没有获取到，JVM会把线程放入锁池。 其他阻塞：运行线程执行sleep、I/O阻塞（等待用户输入），JVM会把线程转入阻塞状态。 waiting状态： 调用wait方法，进入waiting状态，会释放对象锁。被notify唤醒会变为runnable状态，被唤醒是从等待池进入锁池重新竞争锁，状态其实是blocked。获取到锁以后才是runnable。 调用join方法，也会让调用join的线程从runnable变成waiting。 死亡Dead：处于运行状态的线程调用run方法或call方法执行完成后、调用stop方法停止线程、程序执行错误/异常退出，进入死亡状态。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"多线程"}],["meta",{"property":"article:tag","content":"线程池"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-02-12T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-12T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1线程","slug":"_1线程","link":"#_1线程","children":[{"level":3,"title":"线程生命周期","slug":"线程生命周期","link":"#线程生命周期","children":[]},{"level":3,"title":"线程基本方法","slug":"线程基本方法","link":"#线程基本方法","children":[]}]},{"level":2,"title":"2线程的创建方式","slug":"_2线程的创建方式","link":"#_2线程的创建方式","children":[{"level":3,"title":"继承Thread类","slug":"继承thread类","link":"#继承thread类","children":[]},{"level":3,"title":"实现Runnable接口","slug":"实现runnable接口","link":"#实现runnable接口","children":[]},{"level":3,"title":"通过ExecutorService和Callable<Class>实现有返回值的线程","slug":"通过executorservice和callable-class-实现有返回值的线程","link":"#通过executorservice和callable-class-实现有返回值的线程","children":[]},{"level":3,"title":"线程池","slug":"线程池","link":"#线程池","children":[]}]},{"level":2,"title":"3线程池","slug":"_3线程池","link":"#_3线程池","children":[{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"状态","slug":"状态","link":"#状态","children":[]},{"level":3,"title":"JDK","slug":"jdk","link":"#jdk","children":[]},{"level":3,"title":"Spring线程池","slug":"spring线程池","link":"#spring线程池","children":[]}]},{"level":2,"title":"4实践","slug":"_4实践","link":"#_4实践","children":[{"level":3,"title":"线程池实践之jdk线程池","slug":"线程池实践之jdk线程池","link":"#线程池实践之jdk线程池","children":[]},{"level":3,"title":"线程池实践之异步刷新阅读数","slug":"线程池实践之异步刷新阅读数","link":"#线程池实践之异步刷新阅读数","children":[]},{"level":3,"title":"缓存击穿问题","slug":"缓存击穿问题","link":"#缓存击穿问题","children":[]},{"level":3,"title":"线程池实践之异步上传七牛云","slug":"线程池实践之异步上传七牛云","link":"#线程池实践之异步上传七牛云","children":[]}]},{"level":2,"title":"为什么要加锁？","slug":"为什么要加锁","link":"#为什么要加锁","children":[{"level":3,"title":"为什么加锁/分类","slug":"为什么加锁-分类","link":"#为什么加锁-分类","children":[]},{"level":3,"title":"乐观锁/悲观锁","slug":"乐观锁-悲观锁","link":"#乐观锁-悲观锁","children":[]}]},{"level":2,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]}]},{"level":2,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[{"level":3,"title":"CAS","slug":"cas","link":"#cas","children":[]}]},{"level":2,"title":"锁优化","slug":"锁优化","link":"#锁优化","children":[]},{"level":2,"title":"其他锁","slug":"其他锁","link":"#其他锁","children":[{"level":3,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]},{"level":3,"title":"AtomicInteger","slug":"atomicinteger","link":"#atomicinteger","children":[]},{"level":3,"title":"ReadWriteLock接口","slug":"readwritelock接口","link":"#readwritelock接口","children":[]},{"level":3,"title":"CountDownLatch","slug":"countdownlatch","link":"#countdownlatch","children":[]},{"level":3,"title":"CyclicBarrier","slug":"cyclicbarrier","link":"#cyclicbarrier","children":[]},{"level":3,"title":"AQS","slug":"aqs","link":"#aqs","children":[]}]},{"level":2,"title":"计算机内存模型","slug":"计算机内存模型","link":"#计算机内存模型","children":[{"level":3,"title":"缓存一致性问题","slug":"缓存一致性问题","link":"#缓存一致性问题","children":[]},{"level":3,"title":"指令重排","slug":"指令重排","link":"#指令重排","children":[]}]},{"level":2,"title":"java内存模型","slug":"java内存模型","link":"#java内存模型","children":[{"level":3,"title":"并发编程的问题","slug":"并发编程的问题","link":"#并发编程的问题","children":[]},{"level":3,"title":"什么是内存模型","slug":"什么是内存模型","link":"#什么是内存模型","children":[]},{"level":3,"title":"什么是Java内存模型","slug":"什么是java内存模型","link":"#什么是java内存模型","children":[]}]},{"level":2,"title":"Java内存模型的实现","slug":"java内存模型的实现","link":"#java内存模型的实现","children":[{"level":3,"title":"原子性","slug":"原子性","link":"#原子性","children":[]},{"level":3,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":3,"title":"有序性","slug":"有序性","link":"#有序性","children":[]}]},{"level":2,"title":"可见性，原子性，有序性","slug":"可见性-原子性-有序性","link":"#可见性-原子性-有序性","children":[{"level":3,"title":"synchronized","slug":"synchronized-1","link":"#synchronized-1","children":[]},{"level":3,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":3,"title":"比较","slug":"比较","link":"#比较","children":[]}]},{"level":2,"title":"final","slug":"final","link":"#final","children":[{"level":3,"title":"定义","slug":"定义-2","link":"#定义-2","children":[]},{"level":3,"title":"不可变类","slug":"不可变类","link":"#不可变类","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":42.08,"words":12625},"filePathRelative":"tech/java/juc.md","localizedDate":"2023年2月12日","excerpt":"<h1> ·线程</h1>\\n<h2> 1线程</h2>\\n<h3> 线程生命周期</h3>\\n<p>锁池和等待池</p>\\n<p>Java中的对象有两个池，对对象加synchronized锁时必须获得对象锁，没有获得锁的线程进入锁池。获取到锁的线程如果调用了wait()方法就会进入等待池，进入等待池的线程不会竞争对象锁。</p>\\n<p>状态：</p>\\n<ol>\\n<li>新建New：new新建一个线程，处于新建状态。为线程分配内存并初始化成员变量的值。</li>\\n<li>就绪Runnable：可运行态。start启动一个线程，处于就绪状态。</li>\\n<li>运行Running：获取CPU资源后，执行run方法进入运行状态。</li>\\n<li>阻塞Blocked\\n<ol>\\n<li>同步阻塞：运行线程尝试获取同步锁没有获取到，JVM会把线程放入锁池。</li>\\n<li>其他阻塞：运行线程执行sleep、I/O阻塞（等待用户输入），JVM会把线程转入阻塞状态。</li>\\n</ol>\\n</li>\\n<li>waiting状态：\\n<ol>\\n<li>调用wait方法，进入waiting状态，会释放对象锁。被notify唤醒会变为runnable状态，被唤醒是从等待池进入锁池重新竞争锁，状态其实是blocked。获取到锁以后才是runnable。</li>\\n<li>调用join方法，也会让调用join的线程从runnable变成waiting。</li>\\n</ol>\\n</li>\\n<li>死亡Dead：处于运行状态的线程调用run方法或call方法执行完成后、调用stop方法停止线程、程序执行错误/异常退出，进入死亡状态。</li>\\n</ol>","autoDesc":true}');export{l as data};
